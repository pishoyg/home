[color "diff"]
    newMoved=green bold
    oldMoved=red bold

[core]
    # We want to enable the untracked cache extension. This speeds up
    # "git status" by caching the results of the mtime of directories,
    # avoiding a lot of stat() calls. See b7963a017e ("git: Turn on
    # the --untracked-cache on staging servers", 2015-11-23) for
    # details.
    #
    # son.luong: Commenting this out as its implied by feature.experimental
    # untrackedCache = true

    # Use the file written by gc.writeCommitGraph below. See the
    # comment there for why.
    commitGraph = true

    # As explained in "man git-config" this is for those excessively
    # paranoid about state-level actors producing SHA-1
    # collisions. For everything else it just helps. Improves I/O
    # performance on NFS by a *lot*. See
    # https://booking.facebook.com/groups/gitlab/permalink/504493733388468/
    # and
    # https://gitlab.booking.com/backlog/development-velocity/configuration-management/issues/397#note_289067
    # and as shown in the patch that adds it to git.git makes it
    # easier to repair repository corruption.
    checkCollisions = false

[checkout]
    # So that when you have two remotes e.g. "git checkout trunk" will
    # choose "origin" instead of uselessly saying "pathspec 'trunk'
    # did not match any file(s) known to git".
    defaultRemote = origin
[gc]
    # Prune loose unreferenced objects that are more than a few days
    # old, in reality this is is going to be deferred a bit longer
    # since it needs to run into gc.auto=6700 (git's default) or
    # gc.autoPackLimit=50 (git's default) before doing anything.
    #
    # We've run into issues where e.g. book-staging has more than 6700
    # loose objects, but they're all <2wks old (the default for this
    # option). Thus git-gc will attempt to repack, then discover at
    # the end of its run that there's still too many loose objects,
    # and issue a loud warning telling the user to manually prune,
    # details at https://gitlab.booking.com/gitlab/docs/issues/155
    #
    # The root cause should be fixed in git itself as discussed in
    # that ticket, but for now this should be an acceptable
    # compromise. I don't think people will "git add" something
    # they'll want to recover and discover it before Monday rolls
    # around, whereas they do get yelled at by that confusing warning.
    pruneExpire = "4 days ago"

    # Our biggest repos like main.git and affiliate_data.git come with
    # a base back that's larger than 2GB. Reading that entire thing,
    # then computing a new version of it and writing it out again
    # takes a lot of memory and I/O.
    #
    # As of writing this the base pack for main.git and
    # affiliate_data.git is 2.6G and 2.5G, respectively. Using this
    # option on app-staging with everything in hot cache packs it in
    # 2.7G/166s & 850M/50s, respectively. Whereas without it it's
    # 5.2G/214s & 3.6G/80s, respectively.
    #
    # This is mainly a problem in DQS, but in some non-DQS
    # environments like hadoop we also have the git_tree on a mounted
    # FS with limited CPU & memory resources, so those would also slow
    # down. Since it's a pain to detect "is this machine slow?", and
    # no real non-trivial performance loss from not just doing this
    # everywhere, I'm not bothering with making it conditional.
    bigPackThreshold = "1G"

    # Write a commit graph file which can be used to speed up graph
    # traversal, such as git [tag|branch] --contains <commit>. See
    # https://blogs.msdn.microsoft.com/devops/2018/06/25/supercharging-the-git-commit-graph/
    # for more details. As of 2018-09-04 the
    # .git/objects/info/commit-graph file for main.git is 50MB out of
    # a ~4GB .git/objects directory, and 6.5M for puppet.git wit a
    # ~500M .git/objects/ directory.
    writeCommitGraph = true


[diff]
    # Changes the diff algorithm to be more human-friendly in the face
    # of code that's very repetative or boilerplate-like. See the
    # dev.{git,tech} "Git has been updated to 2.10.0 today" post from
    # 2016-09-14. This used to be diff.compactionHeuristic, but the
    # indentHeuristic is the spiritual successor to it.
    indentHeuristic = true

    # Highlights lines differently if they're moves within the same
    # commin, e.g. main/core@2f328a2dad8f is a good example of this in
    # action, adds 18 & removes 18, but colorMoved makes it clear only
    # one line was changed.
    colorMoved = true

    # Rename detection is used for all sorts of things, including "git
    # cherry-pick", "git log -G<rx>" etc. The default is 400, and in
    # practice we run into many warnings where it's complaining that
    # it's not at least 700, or just a bit beyond 1k etc.
    #
    # The algorithm has quadratic behavior, so setting this higher can
    # slow down things (see
    # https://public-inbox.org/git/7e242038-50e5-2cfc-e810-401af78b8cdc@gmail.com/),
    # but I haven't been able to find a case where this matters (even
    # setting this to 10x this and doing a cherry-pick on trunk takes
    # just as long).
    #
    # So I might end up regretting this, but let's bump it so we don't
    # have the warning about increasing this frequently spewed by
    # e.g. the WBSO cronjobs or things that sent git diff output via
    # E-Mail.
    renameLimit = 4096

[push]
    # See puppet.git's 4500bca for detailed rationale, this changes
    # Git's default from "simple", because we'd like to be able to
    # push to trunk from topic branches setup with correct tracking
    # info.
    default = upstream
    autoSetupRemote = true

[fetch]
    # We tend to have long topic branch names. Let's abbreviate the
    # output. See
    # https://github.com/git/git/commit/dc40b24df47af35f486e2c5139121b6cddc2dcb9
    # for a current (as of 2019-02-13) example.
    output = compact

    # When we "fetch" we'd like to aggressively prune upstream remote
    # refs that have gone away `prune` and a bit more dangerously with
    # `pruneTags` any local tags that haven't been pushed to the
    # remote. This helps performance as we won't have repos with an
    # ever growing number of refs while upstream's refs have gone
    # away.
    #
    # See the "PRUNING" section of the git-fetch(1) manpage for how
    # these two interact. As of writing this that section & the
    # pruneTags option only exists in our patched version of
    # booking-git, not upstream git.
    prune = true
    pruneTags = true

    # The GitLab server is already doing receive.fsckObjects=true (see
    # /opt/gitlab/embedded/etc/gitconfig), but let's also do checking
    # on the clients so that we don't propagate corrupt data.
    #
    # This also protects clients against future security issues such
    # as the .gitmodules issue fixed in 2.17.1, see
    # https://github.com/git/git/commit/456bab87b2 for details, in
    # such a we'd like to roll out new clients with fsck protections
    # for such vulnerabilities, even though the (likely to take longer
    # to upgrade) git on the GitLab server hasn't been upgraded to fix
    # it (and that would only address cloning from gitlab.booking.com,
    # not some random 3rd party repos).
    #
    # So this *must not* be disabled. See a6d9711c94 ("Revert & amend
    # "nettools - disable fsck on clone"", 2018-09-03) for an example
    # of what to do & not to do. I.e. if this causes problems we
    # should add offending objects to the /etc/git-fsck-skipList
    # below.
    fsckObjects = true

[receive]
    # We don't use this config on GitLab (but instead
    # /opt/gitlab/embedded/etc/gitconfig), so this is only for local
    # pushes, but let's also set this for good measure.
    fsckObjects = true

[feature]
    # Documentation: https://git-scm.com/docs/git-config#Documentation/git-config.txt-featuremanyFiles
    # - Set pack.useSparse=true
    # - Set fetch.negotiationAlgorithm=skipping
    # - Set fetch.writeCommitGraph=true
    manyFiles = true

    # Documentation: https://git-scm.com/docs/git-config#Documentation/git-config.txt-featureexperimental
    # - Set index.version=4
    # - Set core.untrackedCache=true
    experimental = true
[filter "lfs"]
	required = true
	clean = git-lfs clean -- %f
	smudge = git-lfs smudge -- %f
	process = git-lfs filter-process


[color]
    ui = always

[alias]

    # add
    a = add

    alclmdp = ! git add . && git commit --all --message DEFAULT && git push

    alias = alias  # Reserved for a different command.
    aliases = aliases  # Reserved for a different command.

    # branch
    b = branch  # List all of the branches in your repo.
    bl = branch --all  # List remote as well as local branches.
    bv = branch --verbose  # List with verbosity.
    bvv = branch --verbose --verbose  # List with even more verbosity.
    blv = branch --all --verbose  # List remote as well as local branches with verbosity.
    blvv = branch --all --verbose --verbose  # List remote as well as local branches with even more verbosity.
    bm = branch --merged  # List the branches that you have merged into the branch you’re currently on.
    bmv = branch --merged --verbose  # List the branches that you have merged into the branch you’re currently on with verbosity.
    bmvv = branch --merged --verbose --verbose  # List the branches that you have merged into the branch you’re currently on with even more verbosity.
    bnm = branch --no-merged  # List the branches that you have not yet merged into the branch you’re currently on.
    bnmv = branch --no-merged --verbose  # List the branches that you have not yet merged into the branch you’re currently on with verbosity.
    bnmvv = branch --no-merged --verbose --verbose  # List the branches that you have not yet merged into the branch you’re currently on with even more verbosity.

    b = branch  # Given a name, create a branch with that name.
    bf = branch --force  # Force-create a branch.

    bsut = branch --set-upstream-to  # Set the upstream for a branch.

    bz = branch --move  # Rename a branch.
    bzf = branch --move --force  # Force-rename a branch.

    bc = branch --copy  # Copy a branch.
    bcf = branch --copy --force  # Force-copy a branch.

    bd = branch --delete  # Delete a branch.
    bdf = branch --delete --force  # Force-delete a branch.

    bt = branch --track  # Track a remote branch.

    # commit
    c = commit  # Commit.
    ca = commit --amend  # Amend the last commit.
    cl = commit --all  # Commit, automatically staging files that have been modified and deleted (but new files you have not told Git about are not affected).
    cm = commit --message  # Commit, supplying the message on the commandline.
    clrm = commit --all --reuse-message  # Commit, reusing the message from another commit.
    clrmoh = commit --all --reuse-message=ORIG_HEAD
    cal = commit --amend --all
    clm = commit --all --message

    # clean
    d = clean
    ddr = clean --dry-run  # Display untracked files.
    dd = clean -d  # Recurse. Go to directories.
    df = clean --force
    di = clean --interactive
    dq = clean --quiet
    de = clean --exclude
    dx = clean -x  # Clean everything, including ignored files.
    dxx = clean -X  # Clean only ignored files.
    doc = doc  # Reserved for a different command.
    docs = docs  # Reserved for a different command.

    ddf = clean -d --force  # Force-recurse. Go to directories.
    dqf = clean --quiet --force
    def = clean --exclude --force
    dxf = clean -x --force  # Force-clean everything, including ignored files.
    dxxf = clean -X --force  # Force-clean only ignored files.

    # clone
    e = clone

    # fetch
    f = fetch
    fl = fetch --all
    fo = fetch origin
    fol = fetch origin --all
    fogiom = "!git fetch origin && git rebase --interactive origin/master"
    fogom = "!git fetch origin && git rebase origin/master"

    sync = fogiom

    syncall = "! CUR_DIR="$(pwd)" && cd ~/git_tree && for x in $(find . -name .git -type d -maxdepth 2); do cd $(dirname ${x}) && git pull --rebase && cd ~/git_tree; done && cd "${CUR_DIR}""

    # rebase
    g = rebase
    ga = rebase --abort
    gc = rebase --continue
    gi = rebase --interactive
    giom = rebase --interactive origin/master
    gom = rebase origin/master

    go = rebase --onto

    # stash
    h = stash
    hd = stash drop
    hp = stash pop
    hl = stash list
    hw = stash show
    ha = stash apply
    hb = stash branch
    hc = stash create
    he = stash clear
    hs = stash save
    hr = stash store

    # diff, difftool
    i = diff  # Diff the worktree and the index.

    ino = diff --name-only
    ins = diff --name-status
    is = diff --stat
    ips = diff --patch-with-stat

    ic = diff --cached  # Diff the index and the last commit.
    is = diff --staged  # This is synonymous to `diff --cached`.
    icno = diff --cached --name-only
    icns = diff --cached --name-status
    ics = diff --cached --stat
    icps = diff --cached --patch-with-stat

    ih = diff HEAD  # Diff the worktree and the last commit.
    ihno = diff HEAD --name-only
    ihns = diff HEAD --name-status
    ihs = diff HEAD --stat
    ihps = diff HEAD --patch-with-stat

    iom = diff origin/master  # Diff the worktree and origin/master.
    iomno = diff origin/master --name-only
    iomns = diff origin/master --name-status
    ioms = diff origin/master --stat
    iomps = diff origin/master --patch-with-stat

    ini = diff --no-index  # Diff two files on the filesystem.

    ik = diff --check  # Warn if changes introduce conflict markers or whitespace errors.

    it = difftool

    # for-each-ref
    j = for-each-ref
    jscdrh = for-each-ref --sort=-committerdate refs/heads/

    # tag
    k = tag
    kf = tag --force
    ka = tag --annotate
    ks = tag --sign
    kd = tag --delete
    kv = tag --verify
    kl = tag --list
    km = tag --message

    # log, reflog
    # Filter flags:
    # --  # Filter by paths.
    # -   # Limit the number of commits logged.
    # --since, --after, --until, --before
    # --grep
    # --author
    # --commiter
    l = log
    lg = log --graph
    lo = log --oneline
    ld = log --decorate
    lca = log --color=always
    lpo = log --pretty=oneline
    lps = log --pretty=short
    lpf = log --pretty=full
    lpr = log --pretty=fuller
    lp = log --patch  # Show the differences introduced in each commit.
    ls = log --stat  # Show some abbreviated stats for each commit.
    lhist = log -S  # Show differences that change the number of occurrences of the specified string.
    lss = log --shortstat
    lno = log --name-only
    lns = log --name-status
    lac = log --abbrev-commit
    lrd = log --relative-date
    ll = log --all
    lgo = log --graph --oneline
    lod = log --oneline --decorate
    lgod = log --graph --oneline --decorate
    lgoca = log --graph --oneline --color=always
    lgodca = log --graph --oneline --decorate --color=always
    llgo = log --all --graph --oneline
    llod = log --all --oneline --decorate
    llgod = log --all --graph --oneline --decorate
    llgoca = log --all --graph --oneline --color=always
    llgodca = log --all --graph --oneline --decorate --color=always

    lf = reflog
    lfrd = reflog --relative-date
    lfl = reflog --all

    # merge, mergetool
    m = merge  # Incorporate changes from the named commits (since the time their histories diverged from the current branch) into the current branch.
    ma = merge --abort  # Abort the current conflict resolution process, and try to reconstruct the pre-merge state.
    mc = merge --continue
    mq = merge --quit  # Forget about the current merge in progress. Leave the index and the working tree as-is.
    mt = mergetool

    mff = merge --ff  # Perform a fast-forward merge if the merged-in history is already a descendant of the current history. This is default.
    mnff = merge --no-ff  # Create a merge-commit even if the merged-in history is already a descendant of the current history.
    mffo = merge --ff-only  # Perform a fast-forward merge if merging into a descendant of the current branch, or fail.

    mu = merge @{upstream}

    status = status  # In conflict resolution, show current status.

    add = add  # (Is it possible to skip this step?) In conflict resolution, mark a file as resolved.

    commit = commit  # (`merge --continue` is preffered.) In conflict resolution, complete the merge.

    # config
    n = config
    ng = config --global
    nge = config --global --edit
    nl = config --list

    ngra = "! git config --get-regexp ^alias\\."
    ngras = "! git config --get-regexp ^alias\\. | sed -e s/^alias\\.// -e s/\\ /\\ =\\ /"  # List aliases.
    ngrasg = "! git config --get-regexp ^alias\\. | sed -e s/^alias\\.// -e s/\\ /\\ =\\ / | grep "  # Grep.
    ngrasga = "! git config --get-regexp ^alias\\. | sed -e s/^alias\\.// -e s/\\ /\\ =\\ / | grep \"^$1 = \" #" # Grep alias.
    ngrasgc = "! git config --get-regexp ^alias\\. | sed -e s/^alias\\.// -e s/\\ /\\ =\\ / | grep \" = $1\\b\" #" # Grep command.

    aliasl = ngras
    alias = ngrasga
    aliases = ngrasgc

    ncat = "! cat ~/.gitconfig"
    ncats = "! cat ~/.gitconfig | sed -e 's/^[ \t]*//'"
    ncatsg = "! cat ~/.gitconfig | sed -e 's/^[ \t]*//' | grep"
    ncatsga = "! cat ~/.gitconfig | sed -e 's/^[ \t]*//' | grep \"^$1 = \" #"
    ncatsgc = "! cat ~/.gitconfig | sed -e 's/^[ \t]*//' | grep \" = $1\\b\" #"

    doc = ncatsga
    docs = ncatsgc

    # checkout
    o = checkout  # Given a branch name, switch branches, carrying the index and worktree along.
    oh = checkout HEAD
    oh1 = checkout HEAD^1
    oom = checkout origin/master

    o = checkout  # Given a file name, update the worktree to match the index. This is equivalent to `restore`.
    o- = checkout --  # Update the worktree to match the index. This is equivalent to `restore`.
    oo = checkout --ours
    ot = checkout --theirs
    om = checkout --merge

    ob = checkout -b  # Create a new branch.

    # push
    p = push
    psu = push --set-upstream
    psuo = push --set-upstream origin
    pf = push --force  # Push even if it results in a non-fast-forward merge.
    phrfm = push HEAD:refs/for/master
    pod = push origin --delete  # Delete all listed references from the remote repo.
    pl = push --all  # Push all local branches to the remote repo.
    pt = push --tags  # Push all local tags to the remote repo.

    # pull
    q = pull
    qr = pull --rebase

    # reset
    r = reset  # Reset index to match HEAD, but leave the worktree alone.
    r = reset  # Given a file name, unstage it without writing any changes.
    r- = reset --  # Given a file name, unstage it without writing any changes.
    r = reset  # Given a commit, move the current branch tip backward to that commit, reset the index to match, but leave the worktree alone.

    rh = reset --hard  # Reset index and worktree to match HEAD.
    rh = reset --hard  # Given a commit, reset index and worktree to match that commit, and delete all commits after that commit.
    rs = reset --soft  # Given a commit, reset HEAD to that commit, leaving the index and worktree alone.
    rsh1 = reset --soft HEAD^  # Reset HEAD to HEAD's first parent, leaving the index and worktree alone. This essentially undoes a `commit`.
    rx = reset --mixed  # Reset index, but leave the worktree alone. This is default.
    rg = reset --merge
    rk = reset --keep

    rhh = reset --hard HEAD

    # switch
    s = switch  # Switch to a branch.
    sc = switch --create  # Create a branch.
    sfc = switch --force-create  # Force-create a branch.
    sf = switch --force  # Force-switch to a branch.
    sdc = switch --discard-changes  # Switch to a branch, discarding changes in the worktree and index.
    sm = switch --merge  # Switch to a branch, resolving conflicts in case you have local modifications to one or more files that are different between the current branch and the branch to which you are switching.
    s- = switch -  # Switch to the last branch switched to.
    sd = switch --detach  # Switch to a commit for inspection and discardable experiments.

    sync = sync  # Reserved for a different command.

    # status
    t = status
    ts = status --short

    # restore
    u = restore  # Restore the content of the worktree from the index.
    uc = restore --staged  # Restore the content of the index from HEAD. In other words, unstage a file.
    uwt = restore --worktree  # Restore the content of the worktree from the index.
    ucwt = restore --staged --worktree  # Restore the content of both the index and the worktree from HEAD.
    us = restore --source  # Restore the content of the worktree from a given source.
    ucs = restore --staged --source  # Restore the content of the index from a given source.
    uwts = restore --worktree --source  # Restore the content of the worktree from a given source.
    ucwts = restore --staged --worktree --source  # Restore the content of both the index and the worktree from a given source.

    uo = restore --ours
    ut = restore --theirs
    um = restore --merge

    # revert
    v = revert  # Create a commit that reverts the work done by an earlier commit.
    vm = revert --mainline  # Revert a merge commit, specifying the parent number.
    vne = revert --no-edit  # Revert a commit, without opening the commit message editor.
    vnc = revert --no-commit  # Revert a commit, only applying the changes to the worktree and the index without creating a new commit.
    vc = revert --continue
    vs = revert --skip
    vq = revert --quit
    va = revert --abort

    # show
    w = show  # Shows one or more objects (blobs, trees, tags and commits).
    wmps = show -M -p --stat
    wff = show --format=fuller

    # rm
    x = rm  # Remove files from the working tree and from the index.
    xf = rm --force  # Force-remove files from the working tree and from the index.
    xc = rm --cached  # Remove a file from the index, but keep it in the worktree.
    xcf = rm --cached  --force  # Remove a file from the index, but keep it in the worktree.

    # remote
    y = remote  # Show remote branches.
    ya = remote add  # Add a new remote Git repo.
    yv = remote --verbose  # Show remotes with URLs.
    yw = remote show  # Show a remote.
    ywo = remote show origin  # Show the remote called 'origin'.
    yx = remote remove  # Remove a remote.
    yz = remote rename  # Rename a remote.
    ysh = remote set-head
    ysho = remote set-head origin
    yshoa = remote set-head origin --auto

    # mv
    z = mv  # Move or rename a file, a directory, or a symlink.

    # init
    init = init

    # grep
    grep = grep  # Look for specified patterns in the tracked files in the work tree, blobs registered in the index file, or blobs in given tree objects. Patterns are lists of one or more search expressions separated by newline characters. An empty string as search expression matches all lines.

    # Rename a branch.
    # git branch --move main master
    # git remote rename origin/main origin/master
    # git fetch origin
    # git branch --set-upstream-to origin/master master
    # git remote set-head origin --auto
